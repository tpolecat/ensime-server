package org.ensime.indexer

import com.jolbox.bonecp.BoneCPDataSource
import doobie.imports._
import java.sql.Timestamp
import javax.sql.DataSource
import org.ensime.indexer.DatabaseService.{ FileCheck, FqnSymbol }
import scala.language.higherKinds
import scalaz._, Scalaz._
import scalaz.effect.IO

/**
 * DAO with constructors for pure database programs in IO, operating via the provided DataSource.
 * The implementation is slightly fiddly due to doobie's lack of support for set literals in
 * interpolated SQL strings.
 */
class DatabaseServiceDAO(datasource: BoneCPDataSource) {

  /** Our transactor, which is a simple wrapper around the DataSource. */
  private val xa = DataSourceTransactor[IO](datasource)

  /** A program to shut down the database *and* the underlying DataSource. */
  val shutdown: IO[Unit] =
    sql"shutdown".update.run.void.transact(xa) *> xa.configure(ds => IO(ds.close()))

  /** A program to return a list of all checks. */
  val allFiles: IO[List[FileCheck]] =
    sql"SELECT id, filename, timestamp FROM FILE_CHECK".query[FileCheck].list.transact(xa)

  /** Construct a program to remove symbols and checks associated with the files at the given URIs. */
  def removeFiles[F[_]: Foldable](uris: F[String]): IO[Int] = {
    val (set, go) = inSet(1, uris, HPS.executeUpdate)
    val d1 = HC.prepareStatement(s"DELETE FROM FQN_SYMBOLS WHERE file IN $set")(go)
    val d2 = HC.prepareStatement(s"DELETE FROM FILECHECKS WHERE filename IN $set")(go)
    (d1 *> d2).transact(xa)
  }

  /**
   * Construct a program to determine whether the check associated with the given URI is older
   * than the provided `modified` date, or does not exist at all.
   */
  def outOfDate(uri: String, modified: Long): IO[Boolean] =
    sql"SELECT timestamp FROM FILECHECKS WHERE filename = ${uri}"
      .query[Timestamp]
      .list.map(_.headOption.fold(true)(_.getTime < modified))
      .transact(xa)

  /** Construct a program to save the given check and symbol set to the database. */
  def persist[F[_]: Traverse](check: FileCheck, symbols: F[FqnSymbol]): IO[Unit] = {
    val ins1: ConnectionIO[Int] =
      sql"""
        INSERT INTO FILECHECKS (filename, timestamp) 
        VALUES (${check.filename}, ${check.timestamp})
      """.update.run
    def ins2(s: FqnSymbol): ConnectionIO[Int] =
      sql"""
        INSERT INTO FQN_SYMBOLS (file, path, fqn, descriptor, internal, "source handle", "line in source", "offset in source")
        VALUES (${s.file}, ${s.path}, ${s.fqn}, ${s.descriptor}, ${s.internal}, ${s.source}, ${s.line}, ${s.offset})
      """.update.run
    (ins1 *> symbols.traverseU_(ins2)).transact(xa)
  }

  /** Construct a program to find the symbol associated with the given FQN. */
  def find(fqn: String): IO[Option[FqnSymbol]] =
    sql"""
      SELECT (id, file, path, fqn, descriptor, internal, "source handle", "line in source", "offset in source")
      FROM FQN_SYMBOLS 
      WHERE fqn = $fqn
    """.query[FqnSymbol].list.map(_.headOption).transact(xa)

  /** Construct a program to find the symbols associated with the given FQNs. */
  def find[F[_]: Foldable](fqns: F[String]): IO[List[FqnSymbol]] = {
    val (set, go) = inSet(1, fqns, HPS.executeQuery(HRS.list[FqnSymbol]))
    val sql = """
      SELECT (id, file, path, fqn, descriptor, internal, "source handle", "line in source", "offset in source")
      FROM FQN_SYMBOLS
      WHERE fqn in $set
    """
    HC.prepareStatement(sql)(go).transact(xa)
  }

  /** A program to create the ENSIME schema. */
  val create: IO[Unit] =
    sql"""
      
      create table "FILECHECKS" (
        "id" INTEGER GENERATED BY DEFAULT AS IDENTITY(START WITH 1) NOT NULL PRIMARY KEY,
        "filename" VARCHAR NOT NULL,
        "timestamp" TIMESTAMP NOT NULL
      );      
      create unique index "idx_filename" on "FILECHECKS" ("filename");

      create table "FQN_SYMBOLS" (
        "id" INTEGER GENERATED BY DEFAULT AS IDENTITY(START WITH 1) NOT NULL PRIMARY KEY,
        "file" VARCHAR NOT NULL,
        "path" VARCHAR NOT NULL,
        "fqn" VARCHAR NOT NULL,
        "descriptor" VARCHAR,
        "internal" VARCHAR,
        "source handle" VARCHAR,
        "line in source" INTEGER,
        "offset in source" INTEGER
      );
      create index "idx_fqn" on "FQN_SYMBOLS" ("fqn");
      create unique index "idx_uniq" on "FQN_SYMBOLS" ("fqn","descriptor","internal");

    """.update.run.void.transact(xa)

  // doobie does not have syntax for IN clauses so we have to munge SQL strings to do it. Here,
  // given a 1-based parameter offset, a set of values, and a program in PSIO, return an in-set 
  // parameter literal like "(?,?,?)" and a new computation in that sets the arguments in series 
  // and then yields the result of the provided computation.
  private def inSet[F[_]: Foldable, A: Composite, B](offset: Int, as: F[A], run: PreparedStatementIO[B]): (String, PreparedStatementIO[B]) =
    as.foldRight((0, run)) {
      case (s, (n, a)) => (n + 1, HPS.set(offset + n, s) *> a)
    }.leftMap(n => List.fill(n)("?").mkString("(", ",", ")"))

}
