package org.ensime.indexer

import com.jolbox.bonecp.BoneCPDataSource
import doobie.imports._
import java.sql.Timestamp
import javax.sql.DataSource
import org.ensime.indexer.DatabaseService.{ FileCheck, FqnSymbol }
import scala.language.higherKinds
import scalaz._, Scalaz._
import scalaz.effect.IO

/**
 * DAO with constructors for pure database programs in IO, operating via the provided DataSource.
 * The implementation is slightly fiddly due to doobie's lack of support for set literals in
 * interpolated SQL strings.
 */
class DatabaseServiceDAO(datasource: BoneCPDataSource) {

  /** Our transactor, which is a simple wrapper around the DataSource. */
  private val xa = DataSourceTransactor[IO](datasource)

  /** A program to shut down the database *and* the underlying DataSource. */
  val shutdown: IO[Unit] =
    for {
      c <- xa.configure(ds => IO(ds.getConnection))
      _ <- HC.prepareStatement("shutdown")(HPS.executeUpdate).transK[IO].run(c)
      _ <- xa.configure(ds => IO(ds.close()))
    } yield ()

  /** A program to return a list of all checks. */
  val allFiles: IO[List[FileCheck]] =
    sql"""
      SELECT "id", "filename", "timestamp"
      FROM "FILECHECKS"
    """.query[FileCheck].list.transact(xa)

  /** Construct a program to remove symbols and checks associated with the files at the given URIs. */
  def removeFiles[F[_]: Foldable](uris: F[String]): IO[Int] = {
    val (set, go) = inSet(1, uris, HPS.executeUpdate)
    val d1 = HC.prepareStatement(s"""DELETE FROM "FQN_SYMBOLS" WHERE "file" IN $set""")(go)
    val d2 = HC.prepareStatement(s"""DELETE FROM "FILECHECKS" WHERE "filename" IN $set""")(go)
    (d1 *> d2).transact(xa)
  }

  /**
   * Construct a program to determine whether the check associated with the given URI is older
   * than the provided `modified` date, or does not exist at all.
   */
  def outOfDate(uri: String, modified: Long): IO[Boolean] =
    sql"""
      SELECT "timestamp"
      FROM "FILECHECKS"
      WHERE "filename" = ${uri}
    """.query[Timestamp]
      .option.map(_.fold(true)(_.getTime < modified))
      .transact(xa)

  /** Construct a program to save the given check and symbol set to the database. */
  def persist[F[_]: Traverse](check: FileCheck, symbols: F[FqnSymbol]): IO[Unit] = {
    val ins1: ConnectionIO[Int] =
      sql"""
        INSERT INTO "FILECHECKS" ("filename", "timestamp") 
        VALUES (${check.filename}, ${check.timestamp})
      """.update.run
    def ins2(s: FqnSymbol): ConnectionIO[Int] =
      sql"""
        INSERT INTO FQN_SYMBOLS ("file", "path", "fqn", "descriptor", "internal", "source handle", "line in source", "offset in source")
        VALUES (${s.file}, ${s.path}, ${s.fqn}, ${s.descriptor}, ${s.internal}, ${s.source}, ${s.line}, ${s.offset})
      """.update.run
    (ins1 *> symbols.traverseU_(ins2)).transact(xa)
  }

  /** Construct a program to find the symbol associated with the given FQN. */
  def find(fqn: String): IO[Option[FqnSymbol]] =
    sql"""
      SELECT "id", "file", "path", "fqn", "descriptor", "internal", "source handle", "line in source", "offset in source"
      FROM "FQN_SYMBOLS"
      WHERE "fqn" = $fqn
    """.query[FqnSymbol].list.map(_.headOption).transact(xa)

  /** Construct a program to find the symbols associated with the given FQNs. */
  def find[F[_]: Foldable](fqns: F[String]): IO[List[FqnSymbol]] = {
    val (set, go) = inSet(1, fqns, HPS.executeQuery(HRS.list[FqnSymbol]))
    val sql = s"""
      SELECT "id", "file", "path", "fqn", "descriptor", "internal", "source handle", "line in source", "offset in source"
      FROM "FQN_SYMBOLS"
      WHERE "fqn" in $set
    """
    HC.prepareStatement(sql)(go).transact(xa)
  }

  /** A program to create the ENSIME schema. */
  val create: IO[Unit] =
    sql"""
      
      create table "FILECHECKS" (
        "id" INTEGER GENERATED BY DEFAULT AS IDENTITY(START WITH 1) NOT NULL PRIMARY KEY,
        "filename" VARCHAR NOT NULL,
        "timestamp" TIMESTAMP NOT NULL
      );      
      create unique index "idx_filename" on "FILECHECKS" ("filename");

      create table "FQN_SYMBOLS" (
        "id" INTEGER GENERATED BY DEFAULT AS IDENTITY(START WITH 1) NOT NULL PRIMARY KEY,
        "file" VARCHAR NOT NULL,
        "path" VARCHAR NOT NULL,
        "fqn" VARCHAR NOT NULL,
        "descriptor" VARCHAR,
        "internal" VARCHAR,
        "source handle" VARCHAR,
        "line in source" INTEGER,
        "offset in source" INTEGER
      );
      create index "idx_fqn" on "FQN_SYMBOLS" ("fqn");
      create unique index "idx_uniq" on "FQN_SYMBOLS" ("fqn","descriptor","internal");

    """.update.run.void.transact(xa)

  // doobie does not have syntax for IN clauses so we have to munge SQL strings to do it. Here,
  // given a 1-based parameter offset, a set of values, and a program in PSIO, return an in-set 
  // parameter literal like "(?,?,?)" and a new computation in that sets the arguments in series 
  // and then yields the result of the provided computation.
  private def inSet[F[_]: Foldable, A: Composite, B](offset: Int, as: F[A], run: PreparedStatementIO[B]): (String, PreparedStatementIO[B]) =
    as.foldRight((0, run)) {
      case (s, (n, a)) => (n + 1, HPS.set(offset + n, s) *> a)
    }.leftMap(n => List.fill(n)("?").mkString("(", ",", ")"))

}
